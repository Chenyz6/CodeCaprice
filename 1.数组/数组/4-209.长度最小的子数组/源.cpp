// https://leetcode.cn/problems/minimum-size-subarray-sum/
#include <iostream>
#include <vector>
using namespace std;
/*
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组[numsl, numsl + 1, ..., numsr - 1, numsr]
，并返回其长度。如果不存在符合条件的子数组，返回 0 。
示例 1：

输入：target = 7, nums = [2, 3, 1, 2, 4, 3]
输出：2
解释：子数组[4, 3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1, 4, 4]
输出：1
示例 3：

输入：target = 11, nums = [1, 1, 1, 1, 1, 1, 1, 1]
输出：0
*/

// 超出时间限制
class Solution1 {
public:
	int minSubArrayLen(int target, vector<int>& nums) { // 2, 3, 1, 2, 4, 3    -  7
		int length = 0, sum = 0, min = 0, tag = 0;
		for (int i = 0; i < nums.size(); i++){
			sum = 0;
			length = 0;
			for (int j = i; j < nums.size(); j++) {
				sum += nums[j];
				length++;
				if (sum >= target) {
					if (tag == 0) {
						min = length;
						tag++;
					}
					if (length < min) {
						min = length;
					};
					break;
				}
			}
		}
		return min;
	}
};

// 双指针 滑动窗口
class Solution {
public:
	int minSubArrayLen(int target, vector<int>& nums) { // 2, 3, 1, 2, 4, 3    -  7
		int left = 0, sum = 0, minResult = INT32_MAX, subLength = 0; // subLength 滑动窗口的长度
		for (int right = 0; right < nums.size(); right++)
		{
			sum += nums[right];
			while (sum >= target)
			{
				subLength = (right - left + 1);
				minResult = minResult < subLength ? minResult : subLength;
				sum -= nums[left++];
			}
		}
		return minResult == INT32_MAX ? 0 : minResult; // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
	}
};

int main()
{
	Solution s;
	vector <int> v = { 2, 3, 1, 2, 4, 3 };
	cout << s.minSubArrayLen(7, v);
	system("pause");
}